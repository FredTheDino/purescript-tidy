module Main where

import Prelude

import ArgParse.Basic (ArgParser)
import ArgParse.Basic as Arg
import Control.Parallel (parTraverse)
import Data.Array as Array
import Data.Either (Either(..))
import Data.Foldable (fold, foldMap, foldl, foldr, for_)
import Data.Map as Map
import Data.Maybe (Maybe(..), fromMaybe)
import Data.Monoid (power)
import Data.Newtype (unwrap)
import Data.String (Pattern(..))
import Data.String as String
import Data.Tuple (Tuple(..), snd, uncurry)
import DefaultOperators (defaultOperators)
import Dodo as Dodo
import Effect (Effect)
import Effect.Aff (Aff, launchAff_, makeAff)
import Effect.Class (liftEffect)
import Effect.Class.Console as Console
import Effect.Ref as Ref
import Node.Buffer as Buffer
import Node.Encoding (Encoding(..))
import Node.FS.Aff as FS
import Node.Glob.Basic (expandGlobsCwd)
import Node.Process as Process
import Node.Stream as Stream
import PureScript.CST (RecoveredParserResult(..), parseModule, toRecovered)
import PureScript.CST.Errors (ParseError, printParseError)
import PureScript.CST.Lexer as Lexer
import PureScript.CST.ModuleGraph (ModuleSort(..), sortModules)
import PureScript.CST.Tidy (UnicodeOption(..), defaultFormatOptions, formatModule, toDoc)
import PureScript.CST.Tidy.Precedence (OperatorNamespace(..), Precedence, PrecedenceMap, QualifiedOperator(..), insertOperator, lookupOperator, remapOperators)
import PureScript.CST.TokenStream (TokenStep(..), TokenStream)
import PureScript.CST.TokenStream as TokenStream
import PureScript.CST.Types (Declaration(..), Export(..), FixityOp(..), Module(..), ModuleBody(..), ModuleHeader(..), ModuleName, Name(..), Operator(..), Separated(..), Token(..), Wrapped(..))

type FormatOptions =
  { indent :: Int
  , operators :: Maybe String
  , ribbon :: Number
  , unicode :: UnicodeOption
  , width :: Int
  }

data Command
  = GenerateOperators (Array String)
  | FormatInPlace FormatOptions (Array String)
  | Format FormatOptions

parser :: ArgParser Command
parser =
  Arg.choose "command"
    [ Arg.command [ "generate-operators" ]
        "Generate an operator precedence table for better operator formatting.\nBest used with `spago sources`. Prints to stdout."
        do
          GenerateOperators <$> pursGlobs
            <* Arg.flagHelp
    , Arg.command [ "format-in-place" ]
        "Format source files in place."
        do
          FormatInPlace <$> formatOptions <*> pursGlobs
            <* Arg.flagHelp
    , Arg.command [ "format" ]
        "Format input over stdin."
        do
          Format <$> formatOptions
            <* Arg.flagHelp
    ]
    <* Arg.flagInfo [ "--version", "-v" ] "Shows the current version." "v1.0.0"
    <* Arg.flagHelp
  where
  formatOptions =
    Arg.fromRecord
      { indent:
          Arg.argument [ "--indent", "-i" ]
            "Number of spaces to use as indentation.\nDefaults to 2."
            # Arg.int
            # Arg.default 2
      , operators:
          Arg.argument [ "--operators", "-o" ]
            "Path to an operator table generated by `generate-operators`.\nDefault is to use a pre-generated table of core and contrib."
            # Arg.unformat "FILE_PATH" pure
            # Arg.optional
      , ribbon:
          Arg.argument [ "--ribbon", "-r" ]
            "The ratio of printable width to maximum width.\nFrom 0 to 1. Defaults to 1."
            # Arg.number
            # Arg.default 1.0
      , unicode: unicodeOption
      , width:
          Arg.argument [ "--width", "-w" ]
            "The maximum width of the document in columns.\nDefaults to no maximum."
            # Arg.int
            # Arg.default top
      }

  unicodeOption =
    Arg.choose "unicode argument"
      [ Arg.flag [ "--unicode-source", "-us" ]
          "Unicode punctuation is rendered as it appears in the source input.\nDefault."
          $> UnicodeSource
      , Arg.flag [ "--unicode-always", "-ua" ]
          "Unicode punctuation is always preferred."
          $> UnicodeAlways
      , Arg.flag [ "--unicode-never", "-un" ]
          "Unicode punctuation is never preferred."
          $> UnicodeNever
      ]
      # Arg.default UnicodeSource

  pursGlobs =
    Arg.anyNotFlag "PURS_GLOB" "Globs for PureScript sources."
      # Arg.unfolded1

main :: Effect Unit
main = launchAff_ do
  args <- Array.drop 2 <$> liftEffect Process.argv
  let
    parsedCmd =
      Arg.parseArgs "purs-tidy" "A tidy-upper for PureScript source code." parser args

  case parsedCmd of
    Left err -> do
      Console.log $ Arg.printArgError err
      case err of
        Arg.ArgError _ Arg.ShowHelp ->
          liftEffect $ Process.exit 0
        Arg.ArgError _ (Arg.ShowInfo _) ->
          liftEffect $ Process.exit 0
        _ ->
          liftEffect $ Process.exit 1
    Right cmd ->
      case cmd of
        GenerateOperators globs ->
          generateOperatorsCommand globs
        FormatInPlace options globs ->
          mempty
        Format options ->
          formatCommand options

formatCommand :: FormatOptions -> Aff Unit
formatCommand args = do
  contents <- readStdin
  let
    print = Dodo.print Dodo.plainText
      { pageWidth: args.width
      , ribbonRatio: args.ribbon
      , indentWidth: args.indent
      , indentUnit: power " " args.indent
      }

  operators <-
    case args.operators of
      Nothing ->
        pure $ parseOperatorTable defaultOperators
      Just path -> do
        table <- liftEffect <<< Buffer.toString UTF8 =<< FS.readFile path
        pure $ parseOperatorTable $ String.split (Pattern "\n") table

  case parseModule contents of
    ParseSucceeded ok -> do
      let opts = defaultFormatOptions { operators = remapOperators operators ok, unicode = args.unicode }
      Console.log $ print $ toDoc $ formatModule opts ok
    ParseSucceededWithErrors ok _ -> do
      let opts = defaultFormatOptions { operators = remapOperators operators ok, unicode = args.unicode  }
      Console.log $ print $ toDoc $ formatModule opts ok
    ParseFailed err ->
      Console.log $ printParseError err.error

readStdin :: Aff String
readStdin = makeAff \k -> do
  contents <- Ref.new ""
  Stream.onData Process.stdin \buff -> do
    chunk <- Buffer.toString UTF8 buff
    void $ Ref.modify (_ <> chunk) contents
  Stream.onEnd Process.stdin do
    k <<< Right =<< Ref.read contents
  pure mempty

generateOperatorsCommand :: Array String -> Aff Unit
generateOperatorsCommand globs = do
  sourcePaths <- expandGlobsCwd globs
  modules <- sourcePaths # Array.fromFoldable # parTraverse \path -> do
    contents <- liftEffect <<< Buffer.toString UTF8 =<< FS.readFile path
    pure $ parseModule contents

  let
    parsedModules = modules # Array.mapMaybe case _ of
      ParseSucceeded m -> Just $ toRecovered m
      ParseSucceededWithErrors m _ -> Just m
      _ -> Nothing

  case sortModules (_.header <<< unwrap) parsedModules of
    CycleDetected ms -> do
      let modNames = map (unwrap <<< getModuleName) ms
      Console.error $ String.joinWith "\n"
        [ "Cycle detected in modules:"
        , String.joinWith "\n" $ map (append "  ") modNames
        ]
    Sorted sorted -> do
      let precMap = foldl resolveOperatorExports Map.empty sorted
      for_ (Map.toUnfoldable precMap :: Array _) \(Tuple mbModName ops) -> do
        let modName = foldMap unwrap mbModName
        for_ (Map.toUnfoldable ops :: Array _) \(Tuple (Tuple ns op) prec) -> do
          Console.log $ fold
            [ modName
            , case ns of
                OperatorType -> ".(" <> unwrap op <> ")" <> " type"
                OperatorValue -> ".(" <> unwrap op <> ")"
            , " " <> show prec
            ]

parseOperatorTable :: Array String -> PrecedenceMap
parseOperatorTable = foldr (uncurry insertOperator) Map.empty <<< Array.mapMaybe parseOperatorPrec

parseOperatorPrec :: String -> Maybe (Tuple QualifiedOperator Precedence)
parseOperatorPrec = Lexer.lex >>> tokenStreamToArray >>> case _ of
  Right [ TokSymbolName modName op, TokInt _ prec ] ->
    Just $ Tuple (QualifiedOperator modName OperatorValue (Operator op)) prec
  Right [ TokSymbolName modName op, TokLowerName Nothing "type", TokInt _ prec ] ->
    Just $ Tuple (QualifiedOperator modName OperatorType (Operator op)) prec
  _ ->
    Nothing

resolveOperatorExports :: forall e. PrecedenceMap -> Module e -> PrecedenceMap
resolveOperatorExports precMap mod@(Module { header: ModuleHeader { exports }, body: ModuleBody { decls } }) =
  case exports of
    Nothing ->
      foldl goDecl precMap decls
    Just (Wrapped { value: Separated { head, tail } }) ->
      foldl goExport precMap $ Array.cons head $ map snd tail
  where
  modName =
    getModuleName mod

  remappedPrecMap =
    remapOperators precMap mod

  goExport pm = fromMaybe pm <<< case _ of
    ExportOp (Name { name: op }) -> do
      prec <- lookupOperator (QualifiedOperator Nothing OperatorValue op) remappedPrecMap
      pure $ insertOperator (QualifiedOperator (Just modName) OperatorValue op) prec pm
    ExportTypeOp _ (Name { name: op }) -> do
      prec <- lookupOperator (QualifiedOperator Nothing OperatorType op) remappedPrecMap
      pure $ insertOperator (QualifiedOperator (Just modName) OperatorType op) prec pm
    ExportModule _ (Name { name: exportModName }) -> do
      prec <- Map.lookup (Just exportModName) remappedPrecMap
      pure $ Map.insertWith Map.union (Just modName) prec pm
    _ ->
      Nothing

  goDecl pm = case _ of
    DeclFixity { prec: Tuple _ prec, operator } ->
      case operator of
        FixityValue _ _ (Name { name: op }) ->
          insertOperator (QualifiedOperator (Just modName) OperatorValue op) prec pm
        FixityType _ _ _ (Name { name: op }) ->
          insertOperator (QualifiedOperator (Just modName) OperatorType op) prec pm
    _ ->
      pm

getModuleName :: forall e. Module e -> ModuleName
getModuleName (Module { header: ModuleHeader { name: Name { name } } }) = name

tokenStreamToArray :: TokenStream -> Either ParseError (Array Token)
tokenStreamToArray = go []
  where
  go acc = TokenStream.step >>> case _ of
    TokenEOF _ _ ->
      Right acc
    TokenError _ err _ _ ->
      Left err
    TokenCons tok _ next _ ->
      go (Array.snoc acc tok.value) next
